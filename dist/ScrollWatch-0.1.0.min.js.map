{"version":3,"sources":["ScrollWatch-0.1.0.min.js"],"names":["root","factory","define","amd","exports","module","ScrollWatch","this","instanceId","instanceData","ignoreClass","config","container","window","document","documentElement","watch","watchOnce","inViewClass","scrollDebounce","resizeDebounce","watchOffset","infiniteScroll","infiniteOffset","onElementInView","onElementOutOfView","onInfiniteXInView","onInfiniteYInView","initEvent","extend","retObj","i","key","obj","len","arguments","length","hasOwnProperty","saveContainerElement","isContainerWindow","call","_id","querySelector","saveElements","elements","Array","prototype","slice","querySelectorAll","saveScrollPosition","lastScrollPosition","getScrollPosition","checkViewport","eventType","checkElements","checkInfinite","el","data","responseData","direction","getScrolledDirection","getScrolledAxis","isElementInView","classList","contains","add","splice","remove","axis","viewableRange","scrollSize","callback","isInfiniteScrollPaused","getViewableRange","scrollWidth","scrollHeight","hasScrollPositionChanged","end","clearDebounceTimer","clearTimeout","debounceTimer","addListeners","scrollingElement","getScrollingElement","addEventListener","handler","removeListeners","removeEventListener","getViewportSize","size","w","clientWidth","h","clientHeight","pos","left","top","pageXOffset","pageYOffset","scrollLeft","scrollTop","range","x","y","scrollPos","viewportSize","start","getElementRange","containerCoords","coords","getBoundingClientRect","right","bottom","width","height","scrollDir","position","curScrollPosition","elRange","offset","isElementInVerticalView","isElementInHorizontalView","mergeOptions","opts","Object","defineProperty","value","e","type","debounce","setTimeout","bind","refresh","destroy","pauseInfiniteScroll","resumeInfiniteScroll"],"mappings":"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","file":"ScrollWatch-0.1.0.min.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.ScrollWatch = factory();\n  }\n}(this, function() {\n'use strict';\n\n// Give each instance on the page a unique ID.\nvar instanceId = 0,\n\n\t// Store instance data privately so it can't be accessed/modified.\n\tinstanceData = {},\n\n\tignoreClass = 'scroll-watch-ignore',\n\n\tconfig = {\n\t\t// The default container is window, but we need the actual\n\t\t// documentElement to determine positioning.\n\t\tcontainer: window.document.documentElement,\n\t\twatch: '[data-scroll-watch]',\n\t\twatchOnce: true,\n\t\tinViewClass: 'scroll-watch-in-view',\n\t\tscrollDebounce: 200,\n\t\tresizeDebounce: 500,\n\t\twatchOffset: 0,\n\t\tinfiniteScroll: false,\n\t\tinfiniteOffset: 0,\n\t\tonElementInView: function(){},\n\t\tonElementOutOfView: function(){},\n\t\tonInfiniteXInView: function(){},\n\t\tonInfiniteYInView: function(){}\n\t},\n\n\tinitEvent = 'scrollwatchinit',\n\n\textend = function(retObj) {\n\n\t\tvar len = arguments.length,\n\t\t\ti,\n\t\t\tkey,\n\t\t\tobj;\n\n\t\tretObj = retObj || {};\n\n\t\tfor (i = 1; i < len; i++) {\n\n\t\t\tobj = arguments[i];\n\n\t\t\tif (!obj) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor (key in obj) {\n\n\t\t\t\tif (obj.hasOwnProperty(key)) {\n\n\t\t\t\t\tretObj[key] = obj[key];\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn retObj;\n\n\t},\n\n\t// Get the scrolling container element to watch if it's not the default window/documentElement.\n\tsaveContainerElement = function() {\n\n\t\tif (!isContainerWindow.call(this)) {\n\n\t\t\tinstanceData[this._id].config.container = document.querySelector(instanceData[this._id].config.container);\n\n\t\t}\n\n\t},\n\n\t// Save all elements to watch into an array.\n\tsaveElements = function() {\n\n\t\tinstanceData[this._id].elements = Array.prototype.slice.call(document.querySelectorAll(instanceData[this._id].config.watch + ':not(.' + ignoreClass + ')'));\n\n\t},\n\n\t// Save the scroll position of the scrolling container so we can\n\t// perform comparison checks.\n\tsaveScrollPosition = function() {\n\n\t\tinstanceData[this._id].lastScrollPosition = getScrollPosition.call(this);\n\n\t},\n\n\tcheckViewport = function(eventType) {\n\n\t\tcheckElements.call(this, eventType);\n\t\tcheckInfinite.call(this, eventType);\n\t\tsaveScrollPosition.call(this);\n\n\t},\n\n\t// Determine if the watched elements are viewable within the\n\t// scrolling container.\n\tcheckElements = function(eventType) {\n\n\t\tvar data = instanceData[this._id],\n\t\t\tlen = data.elements.length,\n\t\t\tconfig = data.config,\n\t\t\tinViewClass = config.inViewClass,\n\t\t\tresponseData = {\n\t\t\t\teventType: eventType\n\t\t\t},\n\t\t\tel,\n\t\t\ti;\n\n\t\tfor (i = 0; i < len; i++) {\n\n\t\t\tel = data.elements[i];\n\n\t\t\t// Prepare the data to pass to the callback.\n\t\t\tresponseData.el = el;\n\n\t\t\tif (eventType === 'scroll') {\n\n\t\t\t\tresponseData.direction = getScrolledDirection.call(this, getScrolledAxis.call(this));\n\n\t\t\t}\n\n\t\t\tif (isElementInView.call(this, el)) {\n\n\t\t\t\tif (!el.classList.contains(inViewClass)) {\n\n\t\t\t\t\t// Add a class hook and fire a callback for every\n\t\t\t\t\t// element that just came into view.\n\n\t\t\t\t\tel.classList.add(inViewClass);\n\t\t\t\t\tconfig.onElementInView.call(this, responseData);\n\n\t\t\t\t\tif (config.watchOnce) {\n\n\t\t\t\t\t\t// Remove this element so we don't check it again\n\t\t\t\t\t\t// next time.\n\n\t\t\t\t\t\tdata.elements.splice(i, 1);\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t\ti--;\n\n\t\t\t\t\t\t// Flag this element with the ignore class so we\n\t\t\t\t\t\t// don't store it again if a refresh happens.\n\n\t\t\t\t\t\tel.classList.add(ignoreClass);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif (el.classList.contains(inViewClass)) {\n\n\t\t\t\t\t// Remove the class hook and fire a callback for every\n\t\t\t\t\t// element that just went out of view.\n\n\t\t\t\t\tel.classList.remove(inViewClass);\n\t\t\t\t\tconfig.onElementOutOfView.call(this, responseData);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// Determine if the infinite scroll zone is in view. This could come into\n\t// view by scrolling or resizing. Initial load must also be accounted\n\t// for.\n\tcheckInfinite = function(eventType) {\n\n\t\tvar data = instanceData[this._id],\n\t\t\tconfig = data.config,\n\t\t\ti,\n\t\t\taxis,\n\t\t\tcontainer,\n\t\t\tviewableRange,\n\t\t\tscrollSize,\n\t\t\tcallback,\n\t\t\tresponseData;\n\n\t\tif (config.infiniteScroll && !data.isInfiniteScrollPaused) {\n\n\t\t\taxis = ['x', 'y'];\n\t\t\tcallback = ['onInfiniteXInView', 'onInfiniteYInView'];\n\t\t\tcontainer = config.container;\n\t\t\tviewableRange = getViewableRange.call(this);\n\t\t\tscrollSize = [container.scrollWidth, container.scrollHeight];\n\t\t\tresponseData = {};\n\n\t\t\tfor (i = 0; i < 2; i++) {\n\n\t\t\t\t// If a scroll event triggered this check, verify the scroll\n\t\t\t\t// position actually changed for each axis. This stops\n\t\t\t\t// horizontal scrolls from triggering infiniteY callbacks\n\t\t\t\t// and vice versa. In other words, only trigger an infinite\n\t\t\t\t// callback if that axis was actually scrolled.\n\n\t\t\t\tif ((eventType === 'scroll' && hasScrollPositionChanged.call(this, axis[i]) || eventType === 'resize'|| eventType === 'refresh' || eventType === initEvent) && viewableRange[axis[i]].end + config.infiniteOffset >= scrollSize[i]) {\n\n\t\t\t\t\t// We've scrolled/resized all the way to the right/bottom.\n\n\t\t\t\t\tresponseData.eventType = eventType;\n\n\t\t\t\t\tif (eventType === 'scroll') {\n\n\t\t\t\t\t\tresponseData.direction = getScrolledDirection.call(this, axis[i]);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconfig[callback[i]].call(this, responseData);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tclearDebounceTimer = function() {\n\n\t\tclearTimeout(instanceData[this._id].debounceTimer);\n\n\t},\n\n\t// Add listeners to the scrolling container for each instance.\n\taddListeners = function() {\n\n\t\tvar scrollingElement = getScrollingElement.call(this);\n\n\t\tscrollingElement.addEventListener('scroll', instanceData[this._id].handler, false);\n\t\tscrollingElement.addEventListener('resize', instanceData[this._id].handler, false);\n\n\t},\n\n\tremoveListeners = function() {\n\n\t\tvar scrollingElement = getScrollingElement.call(this);\n\n\t\tscrollingElement.removeEventListener('scroll', instanceData[this._id].handler);\n\t\tscrollingElement.removeEventListener('resize', instanceData[this._id].handler);\n\n\t},\n\n\tgetScrollingElement = function() {\n\n\t\treturn isContainerWindow.call(this) ? window : instanceData[this._id].config.container;\n\n\t},\n\n\t// Get the width and height of viewport/scrolling container.\n\tgetViewportSize = function() {\n\n\t\tvar size = {\n\t\t\t\tw: instanceData[this._id].config.container.clientWidth,\n\t\t\t\th: instanceData[this._id].config.container.clientHeight\n\t\t\t};\n\n\t\treturn size;\n\n\t},\n\n\t// Get the scrollbar position of the scrolling container.\n\tgetScrollPosition = function() {\n\n\t\tvar pos = {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0\n\t\t\t},\n\t\t\tcontainer;\n\n\t\tif (isContainerWindow.call(this)) {\n\n\t\t\tpos.left = window.pageXOffset;\n\t\t\tpos.top = window.pageYOffset;\n\n\n\t\t} else {\n\n\t\t\tcontainer = instanceData[this._id].config.container;\n\n\t\t\tpos.left = container.scrollLeft;\n\t\t\tpos.top = container.scrollTop;\n\n\t\t}\n\n\t\treturn pos;\n\n\t},\n\n\t// Get the pixel range currently viewable within the\n\t// scrolling container.\n\tgetViewableRange = function() {\n\n\t\tvar range = {\n\t\t\t\tx: {},\n\t\t\t\ty: {}\n\t\t\t},\n\t\t\tscrollPos = getScrollPosition.call(this),\n\t\t\tviewportSize = getViewportSize.call(this);\n\n\t\trange.x.start = scrollPos.left;\n\t\trange.x.end =  range.x.start + viewportSize.w;\n\t\trange.x.size = range.x.end - range.x.start;\n\n\t\trange.y.start = scrollPos.top;\n\t\trange.y.end = range.y.start + viewportSize.h;\n\t\trange.y.size = range.y.end - range.y.start;\n\n\t\treturn range;\n\n\t},\n\n\t// Get the pixel range of where this element falls within the\n\t// scrolling container.\n\tgetElementRange = function(el) {\n\n\t\tvar range = {\n\t\t\t\tx: {},\n\t\t\t\ty: {}\n\t\t\t},\n\t\t\tviewableRange = getViewableRange.call(this),\n\t\t\tcoords = el.getBoundingClientRect(),\n\t\t\tcontainerCoords;\n\n\t\tif (isContainerWindow.call(this)) {\n\n\t\t\trange.x.start = coords.left + viewableRange.x.start;\n\t\t\trange.x.end = coords.right + viewableRange.x.start;\n\n\n\t\t\trange.y.start = coords.top + viewableRange.y.start;\n\t\t\trange.y.end = coords.bottom + viewableRange.y.start;\n\n\t\t} else {\n\n\t\t\tcontainerCoords = instanceData[this._id].config.container.getBoundingClientRect();\n\n\t\t\trange.x.start = (coords.left - containerCoords.left) + viewableRange.x.start;\n\t\t\trange.x.end = range.x.start + coords.width;\n\n\t\t\trange.y.start = (coords.top - containerCoords.top) + viewableRange.y.start;\n\t\t\trange.y.end = range.y.start + coords.height;\n\n\t\t}\n\n\t\trange.x.size = range.x.end - range.x.start;\n\t\trange.y.size = range.y.end - range.y.start;\n\n\t\treturn range;\n\n\t},\n\n\t// Determines which axis was just scrolled (x/horizontal or y/vertical).\n\tgetScrolledAxis = function() {\n\n\t\tif (hasScrollPositionChanged.call(this, 'x')) {\n\n\t\t\treturn 'x';\n\n\t\t}\n\n\t\tif (hasScrollPositionChanged.call(this, 'y')) {\n\n\t\t\treturn 'y';\n\n\t\t}\n\n\t},\n\n\tgetScrolledDirection = function(axis) {\n\n\t\tvar scrollDir = {x: ['right', 'left'], y: ['down', 'up']},\n\t\t\tposition = {x: 'left', y: 'top'},\n\t\t\tlastScrollPosition = instanceData[this._id].lastScrollPosition,\n\t\t\tcurScrollPosition = getScrollPosition.call(this);\n\n\t\treturn curScrollPosition[position[axis]] > lastScrollPosition[position[axis]] ? scrollDir[axis][0] : scrollDir[axis][1];\n\n\t},\n\n\thasScrollPositionChanged = function(axis) {\n\n\t\tvar position = {x: 'left', y: 'top'},\n\t\t\tlastScrollPosition = instanceData[this._id].lastScrollPosition,\n\t\t\tcurScrollPosition = getScrollPosition.call(this);\n\n\t\treturn curScrollPosition[position[axis]] !== lastScrollPosition[position[axis]];\n\n\t},\n\n\tisElementInView = function(el) {\n\n\t\tvar viewableRange = getViewableRange.call(this),\n\t\t\telRange = getElementRange.call(this, el),\n\t\t\toffset = instanceData[this._id].config.watchOffset;\n\n\t\treturn isElementInVerticalView(elRange, viewableRange, offset) && isElementInHorizontalView(elRange, viewableRange, offset);\n\n\t},\n\n\tisElementInVerticalView = function(elRange, viewableRange, offset) {\n\n\t\treturn elRange.y.start < viewableRange.y.end + offset && elRange.y.end > viewableRange.y.start - offset;\n\n\t},\n\n\tisElementInHorizontalView = function(elRange, viewableRange, offset) {\n\n\t\treturn elRange.x.start < viewableRange.x.end + offset && elRange.x.end > viewableRange.x.start - offset;\n\n\t},\n\n\tisContainerWindow = function() {\n\n\t\treturn instanceData[this._id].config.container === window.document.documentElement;\n\n\t},\n\n\tmergeOptions = function(opts) {\n\n\t\textend(instanceData[this._id].config, config, opts);\n\n\t},\n\n\tScrollWatch = function(opts) {\n\n\t\tObject.defineProperty(this, '_id', {value: instanceId++});\n\n\t\t// Keep all instance data private, except for the '_id', which will\n\t\t// be the key to get the private data for a specific instance.\n\n\t\tinstanceData[this._id] = {\n\n\t\t\tconfig: {},\n\t\t\telements: [],\n\t\t\tlastScrollPosition: {},\n\t\t\tdebounceTimer: null,\n\t\t\tisInfiniteScrollPaused: false,\n\n\t\t\t// In order to remove listeners later and keep a correct reference\n\t\t\t// to 'this', give each instance it's own event handler.\n\t\t\thandler: function(e) {\n\n\t\t\t\tvar data = instanceData[this._id],\n\t\t\t\t\tconfig = data.config,\n\t\t\t\t\teventType = e.type,\n\t\t\t\t\tdebounce = eventType === 'scroll' ? config.scrollDebounce : config.resizeDebounce;\n\n\t\t\t\tclearDebounceTimer.call(this);\n\n\t\t\t\tdata.debounceTimer = setTimeout(function() {\n\n\t\t\t\t\tcheckViewport.call(this, eventType);\n\n\t\t\t\t// Bind the instance to the function.\n\t\t\t\t}.bind(this), debounce);\n\n\t\t\t// Bind the instance to the method.\n\t\t\t}.bind(this)\n\n\t\t};\n\n\t\tmergeOptions.call(this, opts);\n\t\tsaveContainerElement.call(this);\n\t\taddListeners.call(this);\n\t\tsaveElements.call(this);\n\t\tsaveScrollPosition.call(this);\n\t\tcheckElements.call(this, initEvent);\n\t\tcheckInfinite.call(this, initEvent);\n\n\t};\n\nScrollWatch.prototype = {\n\n\t// Should be manually called by user after loading in new content.\n\trefresh: function() {\n\n\t\tsaveElements.call(this);\n\t\tcheckViewport.call(this, 'refresh');\n\n\t},\n\n\tdestroy: function() {\n\n\t\tremoveListeners.call(this);\n\t\tclearDebounceTimer.call(this);\n\t\tdelete instanceData[this._id];\n\n\t},\n\n\tpauseInfiniteScroll: function() {\n\n\t\tinstanceData[this._id].isInfiniteScrollPaused = true;\n\n\t},\n\n\tresumeInfiniteScroll: function() {\n\n\t\tinstanceData[this._id].isInfiniteScrollPaused = false;\n\n\t}\n\n};\n\nreturn ScrollWatch;\n}));\n"],"sourceRoot":"/source/"}