{"version":3,"sources":["ScrollWatch-0.1.0.min.js"],"names":["root","factory","define","amd","exports","module","ScrollWatch","this","instanceId","instanceData","ignoreClass","config","container","window","document","documentElement","watch","watchOnce","inViewClass","scrollDebounce","resizeDebounce","watchOffset","infiniteScroll","infiniteOffset","onElementInView","onElementOutOfView","onInfiniteXInView","onInfiniteYInView","initEvent","extend","retObj","i","key","obj","len","arguments","length","hasOwnProperty","saveContainerElement","isContainerWindow","call","_id","querySelector","saveElements","elements","Array","prototype","slice","querySelectorAll","saveScrollPosition","lastScrollPosition","getScrollPosition","checkViewport","eventType","checkElements","checkInfinite","el","data","responseData","direction","getScrolledDirection","getScrolledAxis","isElementInView","classList","contains","add","splice","remove","axis","viewableRange","scrollSize","callback","isInfiniteScrollPaused","getViewableRange","scrollWidth","scrollHeight","hasScrollPositionChanged","end","clearDebounceTimer","clearTimeout","debounceTimer","addListeners","scrollingElement","getScrollingElement","addEventListener","handler","removeListeners","removeEventListener","getViewportSize","size","w","clientWidth","h","clientHeight","pos","left","top","pageXOffset","pageYOffset","scrollLeft","scrollTop","range","x","y","scrollPos","viewportSize","start","getElementRange","containerCoords","coords","getBoundingClientRect","right","bottom","width","height","scrollDir","position","curScrollPosition","elRange","offset","isElementInVerticalView","isElementInHorizontalView","mergeOptions","opts","Object","defineProperty","value","e","type","debounce","setTimeout","bind","refresh","destroy","pauseInfiniteScroll","resumeInfiniteScroll"],"mappings":"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","file":"ScrollWatch-0.1.0.min.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.ScrollWatch = factory();\n  }\n}(this, function() {\n'use strict';\n\n// Give each instance on the page a unique ID.\nvar instanceId = 0;\n\n// Store instance data privately so it can't be accessed/modified.\nvar instanceData = {};\n\nvar ignoreClass = 'scroll-watch-ignore';\n\nvar config = {\n\t// The default container is window, but we need the actual\n\t// documentElement to determine positioning.\n\tcontainer: window.document.documentElement,\n\twatch: '[data-scroll-watch]',\n\twatchOnce: true,\n\tinViewClass: 'scroll-watch-in-view',\n\tscrollDebounce: 200,\n\tresizeDebounce: 500,\n\twatchOffset: 0,\n\tinfiniteScroll: false,\n\tinfiniteOffset: 0,\n\tonElementInView: function(){},\n\tonElementOutOfView: function(){},\n\tonInfiniteXInView: function(){},\n\tonInfiniteYInView: function(){}\n};\n\nvar initEvent = 'scrollwatchinit';\n\nvar extend = function(retObj) {\n\n\tvar len = arguments.length;\n\tvar i;\n\tvar key;\n\tvar obj;\n\n\tretObj = retObj || {};\n\n\tfor (i = 1; i < len; i++) {\n\n\t\tobj = arguments[i];\n\n\t\tif (!obj) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tfor (key in obj) {\n\n\t\t\tif (obj.hasOwnProperty(key)) {\n\n\t\t\t\tretObj[key] = obj[key];\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn retObj;\n\n};\n\n// Get the scrolling container element to watch if it's not the default window/documentElement.\nvar saveContainerElement = function() {\n\n\tif (!isContainerWindow.call(this)) {\n\n\t\tinstanceData[this._id].config.container = document.querySelector(instanceData[this._id].config.container);\n\n\t}\n\n};\n\n// Save all elements to watch into an array.\nvar saveElements = function() {\n\n\tinstanceData[this._id].elements = Array.prototype.slice.call(document.querySelectorAll(instanceData[this._id].config.watch + ':not(.' + ignoreClass + ')'));\n\n};\n\n// Save the scroll position of the scrolling container so we can\n// perform comparison checks.\nvar saveScrollPosition = function() {\n\n\tinstanceData[this._id].lastScrollPosition = getScrollPosition.call(this);\n\n};\n\nvar checkViewport = function(eventType) {\n\n\tcheckElements.call(this, eventType);\n\tcheckInfinite.call(this, eventType);\n\tsaveScrollPosition.call(this);\n\n};\n\n// Determine if the watched elements are viewable within the\n// scrolling container.\nvar checkElements = function(eventType) {\n\n\tvar data = instanceData[this._id];\n\tvar len = data.elements.length;\n\tvar config = data.config;\n\tvar inViewClass = config.inViewClass;\n\tvar responseData = {\n\t\teventType: eventType\n\t};\n\tvar el;\n\tvar i;\n\n\tfor (i = 0; i < len; i++) {\n\n\t\tel = data.elements[i];\n\n\t\t// Prepare the data to pass to the callback.\n\t\tresponseData.el = el;\n\n\t\tif (eventType === 'scroll') {\n\n\t\t\tresponseData.direction = getScrolledDirection.call(this, getScrolledAxis.call(this));\n\n\t\t}\n\n\t\tif (isElementInView.call(this, el)) {\n\n\t\t\tif (!el.classList.contains(inViewClass)) {\n\n\t\t\t\t// Add a class hook and fire a callback for every\n\t\t\t\t// element that just came into view.\n\n\t\t\t\tel.classList.add(inViewClass);\n\t\t\t\tconfig.onElementInView.call(this, responseData);\n\n\t\t\t\tif (config.watchOnce) {\n\n\t\t\t\t\t// Remove this element so we don't check it again\n\t\t\t\t\t// next time.\n\n\t\t\t\t\tdata.elements.splice(i, 1);\n\t\t\t\t\tlen--;\n\t\t\t\t\ti--;\n\n\t\t\t\t\t// Flag this element with the ignore class so we\n\t\t\t\t\t// don't store it again if a refresh happens.\n\n\t\t\t\t\tel.classList.add(ignoreClass);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (el.classList.contains(inViewClass)) {\n\n\t\t\t\t// Remove the class hook and fire a callback for every\n\t\t\t\t// element that just went out of view.\n\n\t\t\t\tel.classList.remove(inViewClass);\n\t\t\t\tconfig.onElementOutOfView.call(this, responseData);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Determine if the infinite scroll zone is in view. This could come into\n// view by scrolling or resizing. Initial load must also be accounted\n// for.\nvar checkInfinite = function(eventType) {\n\n\tvar data = instanceData[this._id];\n\tvar config = data.config;\n\tvar i;\n\tvar axis;\n\tvar container;\n\tvar viewableRange;\n\tvar scrollSize;\n\tvar callback;\n\tvar responseData;\n\n\tif (config.infiniteScroll && !data.isInfiniteScrollPaused) {\n\n\t\taxis = ['x', 'y'];\n\t\tcallback = ['onInfiniteXInView', 'onInfiniteYInView'];\n\t\tcontainer = config.container;\n\t\tviewableRange = getViewableRange.call(this);\n\t\tscrollSize = [container.scrollWidth, container.scrollHeight];\n\t\tresponseData = {};\n\n\t\tfor (i = 0; i < 2; i++) {\n\n\t\t\t// If a scroll event triggered this check, verify the scroll\n\t\t\t// position actually changed for each axis. This stops\n\t\t\t// horizontal scrolls from triggering infiniteY callbacks\n\t\t\t// and vice versa. In other words, only trigger an infinite\n\t\t\t// callback if that axis was actually scrolled.\n\n\t\t\tif ((eventType === 'scroll' && hasScrollPositionChanged.call(this, axis[i]) || eventType === 'resize'|| eventType === 'refresh' || eventType === initEvent) && viewableRange[axis[i]].end + config.infiniteOffset >= scrollSize[i]) {\n\n\t\t\t\t// We've scrolled/resized all the way to the right/bottom.\n\n\t\t\t\tresponseData.eventType = eventType;\n\n\t\t\t\tif (eventType === 'scroll') {\n\n\t\t\t\t\tresponseData.direction = getScrolledDirection.call(this, axis[i]);\n\n\t\t\t\t}\n\n\t\t\t\tconfig[callback[i]].call(this, responseData);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nvar clearDebounceTimer = function() {\n\n\tclearTimeout(instanceData[this._id].debounceTimer);\n\n};\n\n// Add listeners to the scrolling container for each instance.\nvar addListeners = function() {\n\n\tvar scrollingElement = getScrollingElement.call(this);\n\n\tscrollingElement.addEventListener('scroll', instanceData[this._id].handler, false);\n\tscrollingElement.addEventListener('resize', instanceData[this._id].handler, false);\n\n};\n\nvar removeListeners = function() {\n\n\tvar scrollingElement = getScrollingElement.call(this);\n\n\tscrollingElement.removeEventListener('scroll', instanceData[this._id].handler);\n\tscrollingElement.removeEventListener('resize', instanceData[this._id].handler);\n\n};\n\nvar getScrollingElement = function() {\n\n\treturn isContainerWindow.call(this) ? window : instanceData[this._id].config.container;\n\n};\n\n// Get the width and height of viewport/scrolling container.\nvar getViewportSize = function() {\n\n\tvar size = {\n\t\t\tw: instanceData[this._id].config.container.clientWidth,\n\t\t\th: instanceData[this._id].config.container.clientHeight\n\t\t};\n\n\treturn size;\n\n};\n\n// Get the scrollbar position of the scrolling container.\nvar getScrollPosition = function() {\n\n\tvar pos = {\n\t\t\tleft: 0,\n\t\t\ttop: 0\n\t\t};\n\tvar container;\n\n\tif (isContainerWindow.call(this)) {\n\n\t\tpos.left = window.pageXOffset;\n\t\tpos.top = window.pageYOffset;\n\n\n\t} else {\n\n\t\tcontainer = instanceData[this._id].config.container;\n\n\t\tpos.left = container.scrollLeft;\n\t\tpos.top = container.scrollTop;\n\n\t}\n\n\treturn pos;\n\n};\n\n// Get the pixel range currently viewable within the\n// scrolling container.\nvar getViewableRange = function() {\n\n\tvar range = {\n\t\t\tx: {},\n\t\t\ty: {}\n\t\t};\n\tvar scrollPos = getScrollPosition.call(this);\n\tvar viewportSize = getViewportSize.call(this);\n\n\trange.x.start = scrollPos.left;\n\trange.x.end =  range.x.start + viewportSize.w;\n\trange.x.size = range.x.end - range.x.start;\n\n\trange.y.start = scrollPos.top;\n\trange.y.end = range.y.start + viewportSize.h;\n\trange.y.size = range.y.end - range.y.start;\n\n\treturn range;\n\n};\n\n// Get the pixel range of where this element falls within the\n// scrolling container.\nvar getElementRange = function(el) {\n\n\tvar range = {\n\t\t\tx: {},\n\t\t\ty: {}\n\t\t};\n\tvar viewableRange = getViewableRange.call(this);\n\tvar coords = el.getBoundingClientRect();\n\tvar containerCoords;\n\n\tif (isContainerWindow.call(this)) {\n\n\t\trange.x.start = coords.left + viewableRange.x.start;\n\t\trange.x.end = coords.right + viewableRange.x.start;\n\n\n\t\trange.y.start = coords.top + viewableRange.y.start;\n\t\trange.y.end = coords.bottom + viewableRange.y.start;\n\n\t} else {\n\n\t\tcontainerCoords = instanceData[this._id].config.container.getBoundingClientRect();\n\n\t\trange.x.start = (coords.left - containerCoords.left) + viewableRange.x.start;\n\t\trange.x.end = range.x.start + coords.width;\n\n\t\trange.y.start = (coords.top - containerCoords.top) + viewableRange.y.start;\n\t\trange.y.end = range.y.start + coords.height;\n\n\t}\n\n\trange.x.size = range.x.end - range.x.start;\n\trange.y.size = range.y.end - range.y.start;\n\n\treturn range;\n\n};\n\n// Determines which axis was just scrolled (x/horizontal or y/vertical).\nvar getScrolledAxis = function() {\n\n\tif (hasScrollPositionChanged.call(this, 'x')) {\n\n\t\treturn 'x';\n\n\t}\n\n\tif (hasScrollPositionChanged.call(this, 'y')) {\n\n\t\treturn 'y';\n\n\t}\n\n};\n\nvar getScrolledDirection = function(axis) {\n\n\tvar scrollDir = {x: ['right', 'left'], y: ['down', 'up']};\n\tvar position = {x: 'left', y: 'top'};\n\tvar lastScrollPosition = instanceData[this._id].lastScrollPosition;\n\tvar curScrollPosition = getScrollPosition.call(this);\n\n\treturn curScrollPosition[position[axis]] > lastScrollPosition[position[axis]] ? scrollDir[axis][0] : scrollDir[axis][1];\n\n};\n\nvar hasScrollPositionChanged = function(axis) {\n\n\tvar position = {x: 'left', y: 'top'};\n\tvar lastScrollPosition = instanceData[this._id].lastScrollPosition;\n\tvar curScrollPosition = getScrollPosition.call(this);\n\n\treturn curScrollPosition[position[axis]] !== lastScrollPosition[position[axis]];\n\n};\n\nvar isElementInView = function(el) {\n\n\tvar viewableRange = getViewableRange.call(this);\n\tvar elRange = getElementRange.call(this, el);\n\tvar offset = instanceData[this._id].config.watchOffset;\n\n\treturn isElementInVerticalView(elRange, viewableRange, offset) && isElementInHorizontalView(elRange, viewableRange, offset);\n\n};\n\nvar isElementInVerticalView = function(elRange, viewableRange, offset) {\n\n\treturn elRange.y.start < viewableRange.y.end + offset && elRange.y.end > viewableRange.y.start - offset;\n\n};\n\nvar isElementInHorizontalView = function(elRange, viewableRange, offset) {\n\n\treturn elRange.x.start < viewableRange.x.end + offset && elRange.x.end > viewableRange.x.start - offset;\n\n};\n\nvar isContainerWindow = function() {\n\n\treturn instanceData[this._id].config.container === window.document.documentElement;\n\n};\n\nvar mergeOptions = function(opts) {\n\n\textend(instanceData[this._id].config, config, opts);\n\n};\n\nvar ScrollWatch = function(opts) {\n\n\tObject.defineProperty(this, '_id', {value: instanceId++});\n\n\t// Keep all instance data private, except for the '_id', which will\n\t// be the key to get the private data for a specific instance.\n\n\tinstanceData[this._id] = {\n\n\t\tconfig: {},\n\t\telements: [],\n\t\tlastScrollPosition: {},\n\t\tdebounceTimer: null,\n\t\tisInfiniteScrollPaused: false,\n\n\t\t// In order to remove listeners later and keep a correct reference\n\t\t// to 'this', give each instance it's own event handler.\n\t\thandler: function(e) {\n\n\t\t\tvar data = instanceData[this._id],\n\t\t\t\tconfig = data.config,\n\t\t\t\teventType = e.type,\n\t\t\t\tdebounce = eventType === 'scroll' ? config.scrollDebounce : config.resizeDebounce;\n\n\t\t\tclearDebounceTimer.call(this);\n\n\t\t\tdata.debounceTimer = setTimeout(function() {\n\n\t\t\t\tcheckViewport.call(this, eventType);\n\n\t\t\t// Bind the instance to the function.\n\t\t\t}.bind(this), debounce);\n\n\t\t// Bind the instance to the method.\n\t\t}.bind(this)\n\n\t};\n\n\tmergeOptions.call(this, opts);\n\tsaveContainerElement.call(this);\n\taddListeners.call(this);\n\tsaveElements.call(this);\n\tsaveScrollPosition.call(this);\n\tcheckElements.call(this, initEvent);\n\tcheckInfinite.call(this, initEvent);\n\n};\n\nScrollWatch.prototype = {\n\n\t// Should be manually called by user after loading in new content.\n\trefresh: function() {\n\n\t\tsaveElements.call(this);\n\t\tcheckViewport.call(this, 'refresh');\n\n\t},\n\n\tdestroy: function() {\n\n\t\tremoveListeners.call(this);\n\t\tclearDebounceTimer.call(this);\n\t\tdelete instanceData[this._id];\n\n\t},\n\n\tpauseInfiniteScroll: function() {\n\n\t\tinstanceData[this._id].isInfiniteScrollPaused = true;\n\n\t},\n\n\tresumeInfiniteScroll: function() {\n\n\t\tinstanceData[this._id].isInfiniteScrollPaused = false;\n\n\t}\n\n};\n\nreturn ScrollWatch;\n}));\n"],"sourceRoot":"/source/"}