{"version":3,"sources":["ScrollWatch-1.0.0.min.js"],"names":["root","factory","define","amd","exports","module","ScrollWatch","this","instanceId","instanceData","ignoreClass","config","container","window","document","documentElement","watch","watchOnce","inViewClass","scrollThrottle","resizeThrottle","watchOffset","infiniteScroll","infiniteOffset","onElementInView","onElementOutOfView","onInfiniteXInView","onInfiniteYInView","initEvent","extend","retObj","i","key","obj","len","arguments","length","hasOwnProperty","throttle","fn","threshhold","scope","last","deferTimer","context","now","Date","args","clearTimeout","setTimeout","apply","saveContainerElement","isContainerWindow","call","_id","querySelector","saveElements","elements","Array","prototype","slice","querySelectorAll","saveScrollPosition","lastScrollPosition","getScrollPosition","checkViewport","eventType","checkElements","checkInfinite","el","data","responseData","direction","getScrolledDirection","getScrolledAxis","isElementInView","classList","contains","add","splice","remove","axis","viewableRange","scrollSize","callback","isInfiniteScrollPaused","getViewableRange","scrollWidth","scrollHeight","hasScrollPositionChanged","end","addListeners","scrollingElement","getScrollingElement","addEventListener","scrollHandler","resizeHandler","removeListeners","removeEventListener","getViewportSize","size","w","clientWidth","h","clientHeight","pos","left","pageXOffset","top","pageYOffset","scrollLeft","scrollTop","range","x","y","scrollPos","viewportSize","start","getElementRange","containerCoords","coords","getBoundingClientRect","right","bottom","width","height","scrollDir","position","curScrollPosition","elRange","offset","isElementInVerticalView","isElementInHorizontalView","mergeOptions","opts","handler","e","type","Object","defineProperty","value","bind","refresh","destroy","pauseInfiniteScroll","resumeInfiniteScroll"],"mappings":"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","file":"ScrollWatch-1.0.0.min.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.ScrollWatch = factory();\n  }\n}(this, function() {\n'use strict';\n\n// Give each instance on the page a unique ID.\nvar instanceId = 0;\n\n// Store instance data privately so it can't be accessed/modified.\nvar instanceData = {};\n\nvar ignoreClass = 'scroll-watch-ignore';\n\nvar config = {\n\t// The default container is window, but we need the actual\n\t// documentElement to determine positioning.\n\tcontainer: window.document.documentElement,\n\twatch: '[data-scroll-watch]',\n\twatchOnce: true,\n\tinViewClass: 'scroll-watch-in-view',\n\tscrollThrottle: 250,\n\tresizeThrottle: 250,\n\twatchOffset: 0,\n\tinfiniteScroll: false,\n\tinfiniteOffset: 0,\n\tonElementInView: function(){},\n\tonElementOutOfView: function(){},\n\tonInfiniteXInView: function(){},\n\tonInfiniteYInView: function(){}\n};\n\nvar initEvent = 'scrollwatchinit';\n\nvar extend = function(retObj) {\n\n\tvar len = arguments.length;\n\tvar i;\n\tvar key;\n\tvar obj;\n\n\tretObj = retObj || {};\n\n\tfor (i = 1; i < len; i++) {\n\n\t\tobj = arguments[i];\n\n\t\tif (!obj) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tfor (key in obj) {\n\n\t\t\tif (obj.hasOwnProperty(key)) {\n\n\t\t\t\tretObj[key] = obj[key];\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn retObj;\n\n};\n\nvar throttle = function (fn, threshhold, scope) {\n\n\tthreshhold = threshhold || 250;\n\n\tvar last;\n\tvar deferTimer;\n\n\treturn function () {\n\n\t\tvar context = scope || this;\n\t\tvar now = +new Date();\n\t\tvar args = arguments;\n\n\t\tif (last && now < last + threshhold) {\n\n\t\t\twindow.clearTimeout(deferTimer);\n\n\t\t\tdeferTimer = setTimeout(function () {\n\n\t\t\t\tlast = now;\n\n\t\t\t\tfn.apply(context, args);\n\n\t\t\t}, threshhold);\n\n\t\t} else {\n\n\t\t\tlast = now;\n\n\t\t\tfn.apply(context, args);\n\n\t\t}\n\n\t};\n\n};\n\n// Get the scrolling container element to watch if it's not the default window/documentElement.\nvar saveContainerElement = function() {\n\n\tif (!isContainerWindow.call(this)) {\n\n\t\tinstanceData[this._id].config.container = document.querySelector(instanceData[this._id].config.container);\n\n\t}\n\n};\n\n// Save all elements to watch into an array.\nvar saveElements = function() {\n\n\tinstanceData[this._id].elements = Array.prototype.slice.call(document.querySelectorAll(instanceData[this._id].config.watch + ':not(.' + ignoreClass + ')'));\n\n};\n\n// Save the scroll position of the scrolling container so we can\n// perform comparison checks.\nvar saveScrollPosition = function() {\n\n\tinstanceData[this._id].lastScrollPosition = getScrollPosition.call(this);\n\n};\n\nvar checkViewport = function(eventType) {\n\n\tcheckElements.call(this, eventType);\n\tcheckInfinite.call(this, eventType);\n\n\t// Chrome does not return 0,0 for scroll position when reloading a page\n\t// that was previously scrolled. To combat this, we will leave the scroll\n\t// position at the default 0,0 when a page is first loaded.\n\tif (eventType !== initEvent) {\n\n\t\tsaveScrollPosition.call(this);\n\n\t}\n\n};\n\n// Determine if the watched elements are viewable within the\n// scrolling container.\nvar checkElements = function(eventType) {\n\n\t// console.log('checkElements eventType: ' + eventType);\n\n\tvar data = instanceData[this._id];\n\tvar len = data.elements.length;\n\tvar config = data.config;\n\tvar inViewClass = config.inViewClass;\n\tvar responseData = {\n\t\teventType: eventType\n\t};\n\tvar el;\n\tvar i;\n\n\tfor (i = 0; i < len; i++) {\n\n\t\tel = data.elements[i];\n\n\t\t// Prepare the data to pass to the callback.\n\t\tresponseData.el = el;\n\n\t\tif (eventType === 'scroll') {\n\n\t\t\tresponseData.direction = getScrolledDirection.call(this, getScrolledAxis.call(this));\n\n\t\t}\n\n\t\tif (isElementInView.call(this, el)) {\n\n\t\t\tif (!el.classList.contains(inViewClass)) {\n\n\t\t\t\t// Add a class hook and fire a callback for every\n\t\t\t\t// element that just came into view.\n\n\t\t\t\tel.classList.add(inViewClass);\n\t\t\t\tconfig.onElementInView.call(this, responseData);\n\n\t\t\t\tif (config.watchOnce) {\n\n\t\t\t\t\t// Remove this element so we don't check it again\n\t\t\t\t\t// next time.\n\n\t\t\t\t\tdata.elements.splice(i, 1);\n\t\t\t\t\tlen--;\n\t\t\t\t\ti--;\n\n\t\t\t\t\t// Flag this element with the ignore class so we\n\t\t\t\t\t// don't store it again if a refresh happens.\n\n\t\t\t\t\tel.classList.add(ignoreClass);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (el.classList.contains(inViewClass)) {\n\n\t\t\t\t// Remove the class hook and fire a callback for every\n\t\t\t\t// element that just went out of view.\n\n\t\t\t\tel.classList.remove(inViewClass);\n\t\t\t\tconfig.onElementOutOfView.call(this, responseData);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Determine if the infinite scroll zone is in view. This could come into\n// view by scrolling or resizing. Initial load must also be accounted\n// for.\nvar checkInfinite = function(eventType) {\n\n\tvar data = instanceData[this._id];\n\tvar config = data.config;\n\tvar i;\n\tvar axis;\n\tvar container;\n\tvar viewableRange;\n\tvar scrollSize;\n\tvar callback;\n\tvar responseData;\n\n\tif (config.infiniteScroll && !data.isInfiniteScrollPaused) {\n\n\t\taxis = ['x', 'y'];\n\t\tcallback = ['onInfiniteXInView', 'onInfiniteYInView'];\n\t\tcontainer = config.container;\n\t\tviewableRange = getViewableRange.call(this);\n\t\tscrollSize = [container.scrollWidth, container.scrollHeight];\n\t\tresponseData = {};\n\n\t\tfor (i = 0; i < 2; i++) {\n\n\t\t\t// If a scroll event triggered this check, verify the scroll\n\t\t\t// position actually changed for each axis. This stops\n\t\t\t// horizontal scrolls from triggering infiniteY callbacks\n\t\t\t// and vice versa. In other words, only trigger an infinite\n\t\t\t// callback if that axis was actually scrolled.\n\n\t\t\tif ((eventType === 'scroll' && hasScrollPositionChanged.call(this, axis[i]) || eventType === 'resize'|| eventType === 'refresh' || eventType === initEvent) && viewableRange[axis[i]].end + config.infiniteOffset >= scrollSize[i]) {\n\n\t\t\t\t// We've scrolled/resized all the way to the right/bottom.\n\n\t\t\t\tresponseData.eventType = eventType;\n\n\t\t\t\tif (eventType === 'scroll') {\n\n\t\t\t\t\tresponseData.direction = getScrolledDirection.call(this, axis[i]);\n\n\t\t\t\t}\n\n\t\t\t\tconfig[callback[i]].call(this, responseData);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Add listeners to the scrolling container for each instance.\nvar addListeners = function() {\n\n\tvar data = instanceData[this._id];\n\tvar scrollingElement = getScrollingElement.call(this);\n\n\tscrollingElement.addEventListener('scroll', data.scrollHandler, false);\n\tscrollingElement.addEventListener('resize', data.resizeHandler, false);\n\n};\n\nvar removeListeners = function() {\n\n\tvar data = instanceData[this._id];\n\tvar scrollingElement = getScrollingElement.call(this);\n\n\tscrollingElement.removeEventListener('scroll', data.scrollHandler);\n\tscrollingElement.removeEventListener('resize', data.resizeHandler);\n\n};\n\nvar getScrollingElement = function() {\n\n\treturn isContainerWindow.call(this) ? window : instanceData[this._id].config.container;\n\n};\n\n// Get the width and height of viewport/scrolling container.\nvar getViewportSize = function() {\n\n\tvar size = {\n\t\t\tw: instanceData[this._id].config.container.clientWidth,\n\t\t\th: instanceData[this._id].config.container.clientHeight\n\t\t};\n\n\treturn size;\n\n};\n\n// Get the scrollbar position of the scrolling container.\nvar getScrollPosition = function() {\n\n\tvar pos = {};\n\tvar container;\n\n\tif (isContainerWindow.call(this)) {\n\n\t\tpos.left = window.pageXOffset;\n\t\tpos.top = window.pageYOffset;\n\n\n\t} else {\n\n\t\tcontainer = instanceData[this._id].config.container;\n\n\t\tpos.left = container.scrollLeft;\n\t\tpos.top = container.scrollTop;\n\n\t}\n\n\treturn pos;\n\n};\n\n// Get the pixel range currently viewable within the\n// scrolling container.\nvar getViewableRange = function() {\n\n\tvar range = {\n\t\t\tx: {},\n\t\t\ty: {}\n\t\t};\n\tvar scrollPos = getScrollPosition.call(this);\n\tvar viewportSize = getViewportSize.call(this);\n\n\trange.x.start = scrollPos.left;\n\trange.x.end =  range.x.start + viewportSize.w;\n\trange.x.size = range.x.end - range.x.start;\n\n\trange.y.start = scrollPos.top;\n\trange.y.end = range.y.start + viewportSize.h;\n\trange.y.size = range.y.end - range.y.start;\n\n\treturn range;\n\n};\n\n// Get the pixel range of where this element falls within the\n// scrolling container.\nvar getElementRange = function(el) {\n\n\tvar range = {\n\t\t\tx: {},\n\t\t\ty: {}\n\t\t};\n\tvar viewableRange = getViewableRange.call(this);\n\tvar coords = el.getBoundingClientRect();\n\tvar containerCoords;\n\n\tif (isContainerWindow.call(this)) {\n\n\t\trange.x.start = coords.left + viewableRange.x.start;\n\t\trange.x.end = coords.right + viewableRange.x.start;\n\n\n\t\trange.y.start = coords.top + viewableRange.y.start;\n\t\trange.y.end = coords.bottom + viewableRange.y.start;\n\n\t} else {\n\n\t\tcontainerCoords = instanceData[this._id].config.container.getBoundingClientRect();\n\n\t\trange.x.start = (coords.left - containerCoords.left) + viewableRange.x.start;\n\t\trange.x.end = range.x.start + coords.width;\n\n\t\trange.y.start = (coords.top - containerCoords.top) + viewableRange.y.start;\n\t\trange.y.end = range.y.start + coords.height;\n\n\t}\n\n\trange.x.size = range.x.end - range.x.start;\n\trange.y.size = range.y.end - range.y.start;\n\n\treturn range;\n\n};\n\n// Determines which axis was just scrolled (x/horizontal or y/vertical).\nvar getScrolledAxis = function() {\n\n\tif (hasScrollPositionChanged.call(this, 'x')) {\n\n\t\treturn 'x';\n\n\t}\n\n\tif (hasScrollPositionChanged.call(this, 'y')) {\n\n\t\treturn 'y';\n\n\t}\n\n};\n\nvar getScrolledDirection = function(axis) {\n\n\tvar scrollDir = {x: ['right', 'left'], y: ['down', 'up']};\n\tvar position = {x: 'left', y: 'top'};\n\tvar lastScrollPosition = instanceData[this._id].lastScrollPosition;\n\tvar curScrollPosition = getScrollPosition.call(this);\n\n\treturn curScrollPosition[position[axis]] > lastScrollPosition[position[axis]] ? scrollDir[axis][0] : scrollDir[axis][1];\n\n};\n\nvar hasScrollPositionChanged = function(axis) {\n\n\tvar position = {x: 'left', y: 'top'};\n\tvar lastScrollPosition = instanceData[this._id].lastScrollPosition;\n\tvar curScrollPosition = getScrollPosition.call(this);\n\n\treturn curScrollPosition[position[axis]] !== lastScrollPosition[position[axis]];\n\n};\n\nvar isElementInView = function(el) {\n\n\tvar viewableRange = getViewableRange.call(this);\n\tvar elRange = getElementRange.call(this, el);\n\tvar offset = instanceData[this._id].config.watchOffset;\n\n\treturn isElementInVerticalView(elRange, viewableRange, offset) && isElementInHorizontalView(elRange, viewableRange, offset);\n\n};\n\nvar isElementInVerticalView = function(elRange, viewableRange, offset) {\n\n\treturn elRange.y.start < viewableRange.y.end + offset && elRange.y.end > viewableRange.y.start - offset;\n\n};\n\nvar isElementInHorizontalView = function(elRange, viewableRange, offset) {\n\n\treturn elRange.x.start < viewableRange.x.end + offset && elRange.x.end > viewableRange.x.start - offset;\n\n};\n\nvar isContainerWindow = function() {\n\n\treturn instanceData[this._id].config.container === window.document.documentElement;\n\n};\n\nvar mergeOptions = function(opts) {\n\n\textend(instanceData[this._id].config, config, opts);\n\n};\n\nvar handler = function(e) {\n\n\tvar eventType = e.type;\n\n\t// For scroll events, only check the viewport if something\n\t// has changed. Fixes issues when using gestures on a page\n\t// that doesn't need to scroll. An event would still fire,\n\t// but the position didn't change  because the\n\t// window/container \"bounced\" back into place.\n\tif (eventType === 'resize' || hasScrollPositionChanged.call(this, 'x') || hasScrollPositionChanged.call(this, 'y')) {\n\n\t\tcheckViewport.call(this, eventType);\n\n\t}\n\n};\n\nvar ScrollWatch = function(opts) {\n\n\t// Protect against missing new keyword.\n\tif (this instanceof ScrollWatch) {\n\n\t\tvar data;\n\n\t\tObject.defineProperty(this, '_id', {value: instanceId++});\n\n\t\t// Keep all instance data private, except for the '_id', which will\n\t\t// be the key to get the private data for a specific instance.\n\n\t\tdata = instanceData[this._id] = {\n\n\t\t\tconfig: {},\n\t\t\t// The elements to watch for this instance.\n\t\t\telements: [],\n\t\t\tlastScrollPosition: {top: 0, left: 0},\n\t\t\tisInfiniteScrollPaused: false\n\n\t\t};\n\n\t\tmergeOptions.call(this, opts);\n\n\t\t// In order to remove listeners later and keep a correct reference\n\t\t// to 'this', give each instance it's own event handler.\n\t\tdata.scrollHandler = throttle(handler.bind(this), data.config.scrollThrottle, this);\n\t\tdata.resizeHandler = throttle(handler.bind(this), data.config.resizeThrottle, this);\n\n\t\tsaveContainerElement.call(this);\n\t\taddListeners.call(this);\n\t\tsaveElements.call(this);\n\t\tcheckViewport.call(this, initEvent);\n\n\t} else {\n\n\t\treturn new ScrollWatch(opts);\n\n\t}\n\n};\n\nScrollWatch.prototype = {\n\n\t// Should be manually called by user after loading in new content.\n\trefresh: function() {\n\n\t\tsaveElements.call(this);\n\t\tcheckViewport.call(this, 'refresh');\n\n\t},\n\n\tdestroy: function() {\n\n\t\tremoveListeners.call(this);\n\t\tdelete instanceData[this._id];\n\n\t},\n\n\tpauseInfiniteScroll: function() {\n\n\t\tinstanceData[this._id].isInfiniteScrollPaused = true;\n\n\t},\n\n\tresumeInfiniteScroll: function() {\n\n\t\tinstanceData[this._id].isInfiniteScrollPaused = false;\n\n\t}\n\n};\n\nreturn ScrollWatch;\n}));\n"],"sourceRoot":"/source/"}